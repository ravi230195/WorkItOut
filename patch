                                                                                                                                                                                                                                                                          (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/components/screens/ExerciseSetupScreen.tsx b/components/screens/ExerciseSetupScreen.tsx
index 3bdcb0ade9ace96516df18aad260edd01962c802..f6544c570b5f00de373cf3b3b31338791bf1cdd1 100644
--- a/components/screens/ExerciseSetupScreen.tsx
+++ b/components/screens/ExerciseSetupScreen.tsx
@@ -27,50 +27,51 @@ import {
   recordSetReorder,
   recordSetUpdate,
 } from "../routine-editor/journal";
 import { collapseJournal, journalIsNoop } from "../routine-editor/collapseJournal";
 import { runJournal, type ExIdMap } from "../routine-editor/journalRunner";
 import { tempId, type Id } from "../routine-editor/journalTypes";
 
 /* =======================================================================================
    Types used by this screen (UI state only)
    ======================================================================================= */
 
 type SavedExerciseWithDetails = UserRoutineExercise & {
   exercise_name?: string;
   category?: string;
   exercise_id: number;
   muscle_group?: string;
 };
 
 type ExerciseMeta = { exercise_id: number; name: string; muscle_group?: string | null };
 
 type UISet = {
   id: Id; // DB id (>0) or temp (<0)
   set_order: number;
   reps: string; // keep strings for controlled inputs
   weight: string;
+  done?: boolean;
 };
 
 type UIExercise = {
   id: Id; // templateId (>0) or temp (<0)
   templateId?: number; // present if existing in DB
   exerciseId: number; // exercises.exercise_id
   name: string;
   muscle_group?: string;
   loaded: boolean; // sets loaded
   expanded: boolean;
   sets: UISet[];
 };
 
 /* =======================================================================================
    Props
    ======================================================================================= */
 
 interface ExerciseSetupScreenProps {
   routineId: number;
   routineName: string;
   selectedExercisesForSetup: Exercise[];
   setSelectedExercisesForSetup: (exercises: Exercise[]) => void;
   onBack: () => void;
   onSave: () => void;
   onAddMoreExercises: () => void;
@@ -79,52 +80,57 @@ interface ExerciseSetupScreenProps {
   access?: RoutineAccess;
   bottomBar?: React.ReactNode;
 }
 
 /* =======================================================================================
    Component
    ======================================================================================= */
 
 export function ExerciseSetupScreen({
   routineId,
   routineName,
   selectedExercisesForSetup,
   setSelectedExercisesForSetup,
   onBack,
   onSave,
   onAddMoreExercises,
   isEditingExistingRoutine = false,
   onShowExerciseSelector,
   access = RoutineAccess.Editable,
 }: ExerciseSetupScreenProps) {
   const { userToken } = useAuth();
 
   const [exercises, setExercises] = useState<UIExercise[]>([]);
   const [loadingSaved, setLoadingSaved] = useState(true);
   const [savingAll, setSavingAll] = useState(false);
+  const [savingWorkout, setSavingWorkout] = useState(false);
   const [loadingSets, setLoadingSets] = useState<Record<string, boolean>>({}); // key by exercise id as string
 
+  type ScreenMode = "plan" | "workout";
+  const [screenMode, setScreenMode] = useState<ScreenMode>("plan");
+  const inWorkout = screenMode === "workout";
+
   // Append-only action journal (doesn't trigger re-renders)
   const journalRef = useRef(makeJournal());
 
   /* -------------------------------------------------------------------------------------
      Utilities
      ------------------------------------------------------------------------------------- */
 
   // ‚úÖ NEW: Normalize placeholders so "Undefined"/"Unknown"/"null"/"N/A" don't block fallback
   const normalizeField = (val: unknown): string => {
     const s = (val ?? "").toString().trim();
     if (!s) return "";
     if (/^(unknown|undefined|null|n\/a)$/i.test(s)) return "";
     return s;
   };
 
   const fetchExerciseMeta = async (id: number): Promise<ExerciseMeta | null> => {
     try {
       // Uses supabaseAPI.getExercise(id) which is cached internally
       const metaAny = await supabaseAPI.getExercise(id);
       const meta = Array.isArray(metaAny) ? (metaAny as any[])[0] : (metaAny as any);
       return (meta ?? null) as ExerciseMeta | null;
     } catch (error) {
       logger.error("üîç DGB [EXERCISE-SETUP] fetchExerciseMeta error:", error);
       return null;
     }
@@ -257,51 +263,51 @@ export function ExerciseSetupScreen({
 
     // If selector didn't include muscle_group or name, fetch per-exercise meta now
     let name = x.name?.trim() || "";
     let muscle_group = ((x as any).muscle_group || "")?.toString().trim() || "";
 
     if (!name || !muscle_group) {
       const metaTimer = performanceTimer.start('ExerciseSetup - fetchExerciseMeta in addNewExercise');
       const meta = await fetchExerciseMeta(x.exercise_id);
       if (meta) {
         if (!name) name = normalizeField(meta.name) || name;
         if (!muscle_group) muscle_group = normalizeField(meta.muscle_group) || muscle_group;
       }
       metaTimer.endWithLog('debug');
     }
 
     // 1) Update UI
     setExercises((prev) => [
       ...prev,
       {
         id: newExId,
         exerciseId: x.exercise_id,
         name,
         muscle_group: muscle_group || undefined,
         loaded: true,
         expanded: true,
-        sets: [{ id: initialSetId, set_order: 1, reps: "0", weight: "0" }],
+        sets: [{ id: initialSetId, set_order: 1, reps: "0", weight: "0", ...(inWorkout ? { done: false } : {}) }],
       },
     ]);
 
     // 2) Record in journal
     recordExAdd(journalRef.current, newExId, x.exercise_id, name);
     recordSetAdd(journalRef.current, newExId, initialSetId, 1, "0", "0");
     
     timer.endWithLog('debug');
   };
 
   const toggleExpanded = async (exId: Id) => {
     const ex = exercises.find((e) => e.id === exId);
     if (!ex) return;
 
     if (!ex.loaded && ex.templateId) {
       await ensureSetsLoaded(ex);
     }
 
     withExercises((draft) => {
       const i = draft.findIndex((d) => d.id === exId);
       if (i >= 0) draft[i].expanded = !draft[i].expanded;
     });
   };
 
   const computeNextOrder = (sets: UISet[]) =>
@@ -316,50 +322,51 @@ export function ExerciseSetupScreen({
     if (!current.loaded && current.templateId) {
       await ensureSetsLoaded(current);
     }
 
     withExercises((draft) => {
       const i = draft.findIndex((d) => d.id === exId);
       if (i < 0) return;
 
       const ex = draft[i];
       const nextOrder = computeNextOrder(ex.sets);
 
       const prevSet =
         ex.sets.length > 0
           ? ex.sets.slice().sort((a, b) => a.set_order - b.set_order)[ex.sets.length - 1]
           : undefined;
 
       const newSetId: Id = tempId();
       const initialReps = prevSet ? prevSet.reps : "0";
       const initialWeight = prevSet ? prevSet.weight : "0";
 
       ex.sets.push({
         id: newSetId,
         set_order: nextOrder,
         reps: initialReps,
         weight: initialWeight,
+        ...(inWorkout ? { done: false } : {}),
       });
 
       recordSetAdd(journalRef.current, exId, newSetId, nextOrder, initialReps, initialWeight);
     });
   };
 
   // robust key resolver: expect set id; also accept order number.
   const resolveSetId = (ex: UIExercise, rawKey: unknown): Id | null => {
     if (typeof rawKey === "number") {
       const byId = ex.sets.find((s) => s.id === rawKey);
       if (byId) return byId.id;
       const byOrder = ex.sets.find((s) => s.set_order === rawKey);
       return byOrder ? byOrder.id : null;
     }
     if (typeof rawKey === "string") {
       const n = Number(rawKey);
       if (!Number.isNaN(n)) {
         const byId = ex.sets.find((s) => s.id === n);
         if (byId) return byId.id;
         const byOrder = ex.sets.find((s) => s.set_order === n);
         return byOrder ? byOrder.id : null;
       }
     }
     return null;
   };
@@ -397,50 +404,123 @@ export function ExerciseSetupScreen({
       if (setId == null) return;
 
       const before = ex.sets.slice();
       ex.sets = ex.sets.filter((s) => s.id !== setId);
 
       recordSetDelete(journalRef.current, exId, setId);
 
       // reindex 1..N and record reorders for DB sets only
       let order = 1;
       for (const s of ex.sets) {
         const old = before.find((b) => b.id === s.id);
         s.set_order = order++;
         if (s.id > 0 && old && old.set_order !== s.set_order) {
           recordSetReorder(journalRef.current, exId, s.id, s.set_order);
         }
       }
     });
   };
 
   const onDeleteExercise = (exId: Id) => {
     if (access === RoutineAccess.ReadOnly) return;
     setExercises((prev) => prev.filter((e) => e.id !== exId));
     recordExDelete(journalRef.current, exId);
   };
 
+  const onToggleDone = (exId: Id, rawKey: unknown, done: boolean) => {
+    withExercises((draft) => {
+      const ex = draft.find((d) => d.id === exId);
+      if (!ex) return;
+      const setId = resolveSetId(ex, rawKey);
+      if (setId == null) return;
+      const s = ex.sets.find((st) => st.id === setId);
+      if (s) s.done = done;
+    });
+  };
+
+  const startWorkout = () => {
+    // reset any stale journal entries and mark all sets as not done locally
+    journalRef.current = makeJournal();
+    setExercises((prev) =>
+      prev.map((ex) => ({
+        ...ex,
+        sets: ex.sets.map((s) => ({ ...s, done: false })),
+      }))
+    );
+    setScreenMode("workout");
+  };
+
+  const endWorkout = async () => {
+    if (!userToken) {
+      toast.error("Please sign in to save workout");
+      return;
+    }
+
+    setSavingWorkout(true);
+    try {
+      // Persist workout session in one go at workout end
+      const workout = await supabaseAPI.startWorkout(routineId);
+
+      for (let i = 0; i < exercises.length; i++) {
+        const ex = exercises[i];
+        const wEx = await supabaseAPI.addWorkoutExercise(workout.id, ex.exerciseId, i + 1);
+        for (const s of ex.sets) {
+          await supabaseAPI.addWorkoutSet(
+            wEx.id,
+            s.set_order,
+            Number(s.reps) || 0,
+            Number(s.weight) || 0,
+            s.done ? new Date().toISOString() : undefined
+          );
+        }
+      }
+
+      await supabaseAPI.endWorkout(workout.id);
+
+      // Apply workout edits to the routine template
+      const journal = journalRef.current;
+      const exIdMap: ExIdMap = {};
+      for (const e of exercises) {
+        exIdMap[e.id] = { templateId: e.templateId, exerciseId: e.exerciseId };
+      }
+      const plan = collapseJournal(journal);
+      if (!journalIsNoop(journal)) {
+        await runJournal(plan, routineId, exIdMap);
+      }
+      journalRef.current = makeJournal();
+
+      await reloadFromDb();
+      toast.success("Workout saved!");
+      setScreenMode("plan");
+    } catch (e) {
+      logger.error(String(e));
+      toast.error("Failed to save workout");
+    } finally {
+      setSavingWorkout(false);
+    }
+  };
+
   /* =======================================================================================
      Save / Cancel
      ======================================================================================= */
 
   const reloadFromDb = async () => {
     setLoadingSaved(true);
     try {
       const loaded = await loadRoutineExercisesWithSets(routineId, {
         concurrency: SETS_PREFETCH_CONCURRENCY,
         timer: performanceTimer,
       });
       const uiList: UIExercise[] = loaded.map((r) => ({
         id: r.templateId,
         templateId: r.templateId,
         exerciseId: r.exerciseId,
         name: r.name,
         muscle_group: r.muscle_group,
         loaded: true,
         expanded: false,
         sets: r.sets,
       }));
       setExercises(uiList);
     } catch (e) {
       logger.error(String(e));
       toast.error("Failed to refresh");
@@ -491,143 +571,172 @@ export function ExerciseSetupScreen({
      Derived & Render
      ======================================================================================= */
 
   const hasUnsaved = useMemo(() => !journalIsNoop(journalRef.current), [exercises]);
   const visible = exercises;
 
   const renderHeader = () => (
     <ScreenHeader
       title={routineName || "Routine"}
       onBack={onBack}
       {...(access === RoutineAccess.Editable
         ? {
             onAdd: () => {
               if (isEditingExistingRoutine && onShowExerciseSelector) onShowExerciseSelector();
               else onAddMoreExercises();
             },
           }
         : {})}
       showBorder={false}
       denseSmall
       contentHeightPx={74}
       titleClassName="text-[17px] font-bold"
     />
   );
 
-  const renderBottomBar = () =>
-    hasUnsaved ? (
-      <FooterBar size="md" bg="translucent" align="between" maxContent="responsive" innerClassName="w-full gap-3">
-        <div className="flex w-full gap-3">
-          <TactileButton
-            variant="secondary"
-            onClick={onCancelAll}
-            disabled={access === RoutineAccess.ReadOnly}
-            className={`flex-1 h-11 md:h-12 ${
-              access === RoutineAccess.ReadOnly
-                ? "opacity-50 cursor-not-allowed bg-gray-100 text-gray-400 border-gray-200"
-                : "bg-transparent border-warm-brown/20 text-warm-brown/60 hover:bg-soft-gray"
-            } font-medium`}
-          >
-            CANCEL ALL
-          </TactileButton>
+  const renderBottomBar = () => {
+    if (screenMode === "plan") {
+      if (hasUnsaved) {
+        return (
+          <FooterBar size="md" bg="translucent" align="between" maxContent="responsive" innerClassName="w-full gap-3">
+            <div className="flex w-full gap-3">
+              <TactileButton
+                variant="secondary"
+                onClick={onCancelAll}
+                disabled={access === RoutineAccess.ReadOnly}
+                className={`flex-1 h-11 md:h-12 ${
+                  access === RoutineAccess.ReadOnly
+                    ? "opacity-50 cursor-not-allowed bg-gray-100 text-gray-400 border-gray-200"
+                    : "bg-transparent border-warm-brown/20 text-warm-brown/60 hover:bg-soft-gray"
+                } font-medium`}
+              >
+                CANCEL ALL
+              </TactileButton>
+              <TactileButton
+                onClick={onSaveAll}
+                disabled={savingAll || access === RoutineAccess.ReadOnly}
+                className={`flex-1 h-11 md:h-12 font-medium border-0 transition-all ${
+                  access === RoutineAccess.ReadOnly
+                    ? "opacity-50 cursor-not-allowed bg-gray-400"
+                    : "bg-primary hover:bg-primary-hover text-primary-foreground btn-tactile"
+                }`}
+              >
+                {savingAll ? "SAVING..." : `SAVE ALL`}
+              </TactileButton>
+            </div>
+          </FooterBar>
+        );
+      }
+      return (
+        <FooterBar size="md" bg="translucent" align="center" maxContent="responsive" innerClassName="w-full">
           <TactileButton
-            onClick={onSaveAll}
-            disabled={savingAll || access === RoutineAccess.ReadOnly}
-            className={`flex-1 h-11 md:h-12 font-medium border-0 transition-all ${
-              access === RoutineAccess.ReadOnly
-                ? "opacity-50 cursor-not-allowed bg-gray-400"
-                : "bg-primary hover:bg-primary-hover text-primary-foreground btn-tactile"
-            }`}
+            onClick={startWorkout}
+            className="w-full h-11 md:h-12 bg-primary hover:bg-primary-hover text-primary-foreground btn-tactile"
           >
-            {savingAll ? "SAVING..." : `SAVE ALL`}
+            START WORKOUT
           </TactileButton>
-        </div>
+        </FooterBar>
+      );
+    }
+    return (
+      <FooterBar size="md" bg="translucent" align="center" maxContent="responsive" innerClassName="w-full">
+        <TactileButton
+          onClick={endWorkout}
+          disabled={savingWorkout}
+          className="w-full h-11 md:h-12 bg-primary hover:bg-primary-hover text-primary-foreground btn-tactile"
+        >
+          {savingWorkout ? "SAVING..." : "END WORKOUT"}
+        </TactileButton>
       </FooterBar>
-    ) : null;
+    );
+  };
 
   const renderExerciseCard = (ex: UIExercise) => {
     const isLoading = !!loadingSets[String(ex.id)];
 
     const items = ex.loaded
       ? ex.sets
           .slice()
           .sort((a, b) => a.set_order - b.set_order)
           .map((s) => ({
             key: s.id, // child will pass this back; our resolver also handles order numbers
             order: s.set_order,
             reps: s.reps,
             weight: s.weight,
             removable: ex.sets.length > 1,
+            done: s.done,
           }))
       : [];
 
     // Subtitle: "<muscle_group> ‚Ä¢ <N Sets>" (when loaded) or just muscle group while loading.
     const subtitle = (() => {
       const mg = normalizeField(ex.muscle_group);
       if (ex.loaded) {
         const count = items.length;
         const setsLabel = count === 1 ? "1 Set" : `${count} Sets`;
         return mg ? `${mg} ‚Ä¢ ${setsLabel}` : setsLabel;
       }
       return mg || "";
     })();
 
     return (
       <div key={ex.id} className="scroll-mt-24">
         <ExpandingCard
           variant="solid"
           size="md"
           expanded={ex.expanded}
           onToggle={() => toggleExpanded(ex.id)}
           title={ex.name}
           subtitle={subtitle}
           leading={
             <div className="w-10 h-10 md:w-12 md:h-12 bg-muted rounded-lg flex items-center justify-center overflow-hidden">
               <span className="text-sm md:text-base font-medium text-muted-foreground">
                 {ex.name.substring(0, 2).toUpperCase()}
               </span>
             </div>
           }
           className="bg-card/80 border-border"
           bodyClassName="pt-2"
         >
           {isLoading || !ex.loaded ? (
             <div className="flex items-center justify-center py-4">
               <div className="animate-spin w-4 h-4 border-2 border-warm-coral border-t-transparent rounded-full" />
               <span className="ml-2 text-sm text-warm-brown/60">Loading sets...</span>
             </div>
           ) : (
             <ExerciseSetEditorCard
               name={ex.name}
               initials={ex.name.substring(0, 2)}
               items={items}
+              mode={inWorkout ? "workout" : "edit"}
               onChange={(key, field, value) =>
                 onChangeSet(ex.id, key as unknown, field as "reps" | "weight", value)
               }
-              onRemove={(key) => onRemoveSet(ex.id, key as unknown)}
+              onRemove={inWorkout ? undefined : (key) => onRemoveSet(ex.id, key as unknown)}
               onAdd={() => onAddSet(ex.id)}
-              onDeleteExercise={() => onDeleteExercise(ex.id)}
+              onDeleteExercise={inWorkout ? undefined : () => onDeleteExercise(ex.id)}
+              onToggleDone={inWorkout ? (key, done) => onToggleDone(ex.id, key, done) : undefined}
               deleteDisabled={access === RoutineAccess.ReadOnly}
               disabled={access === RoutineAccess.ReadOnly}
               onFocusScroll={(e) =>
                 setTimeout(
                   () =>
                     e.currentTarget.scrollIntoView({
                       block: "center",
                       behavior: "smooth",
                     }),
                   60
                 )
               }
               className="mb-2"
             />
           )}
         </ExpandingCard>
       </div>
     );
   };
 
   const renderExerciseList = () => {
     if (loadingSaved) {
       return (
         <div className="space-y-3">
           {[1, 2].map((i) => (
@@ -635,45 +744,45 @@ export function ExerciseSetupScreen({
               <div className="w-9 h-9 md:w-10 md:h-10 bg-muted rounded-lg" />
               <div className="flex-1 space-y-2">
                 <div className="h-4 bg-muted rounded w-3/4" />
                 <div className="h-3 bg-muted rounded w-1/2" />
               </div>
             </div>
           ))}
         </div>
       );
     }
     if (visible.length === 0) {
       return (
         <div className="text-center py-4">
           <p className="text-muted-foreground">Ready to add exercises to this routine</p>
         </div>
       );
     }
     return <div className="space-y-3">{visible.map((ex) => renderExerciseCard(ex))}</div>;
   };
 
   return (
     <AppScreen
       header={renderHeader()}
       maxContent="responsive"
       padContent={false}
-      contentBottomPaddingClassName={hasUnsaved ? "pb-24" : ""}
+      contentBottomPaddingClassName={hasUnsaved || inWorkout ? "pb-24" : ""}
       bottomBar={renderBottomBar()}
       showHeaderBorder={false}
       showBottomBarBorder={false}
       contentClassName=""
     >
       <Stack gap="fluid">
         <Spacer y="sm" />
         <Section variant="plain" padding="none">
           <div className="mt-2 mb-6">
             <h3 className="text-xs md:text-sm text-muted-foreground uppercase tracking-wider mb-3">
               EXERCISES IN ROUTINE ({visible.length})
             </h3>
             {renderExerciseList()}
           </div>
         </Section>
       </Stack>
     </AppScreen>
   );
 }
diff --git a/components/sets/ExerciseSetEditorCard.tsx b/components/sets/ExerciseSetEditorCard.tsx
index f0e99896b9ad42bcf6143379e14f4d5a2470d9f5..82cd9f1c9c1f0a557d0d97558283d7a92237bf69 100644
--- a/components/sets/ExerciseSetEditorCard.tsx
+++ b/components/sets/ExerciseSetEditorCard.tsx
@@ -1,109 +1,115 @@
 // components/sets/ExerciseSetEditorCard.tsx
 import * as React from "react";
 import { TactileButton } from "../TactileButton";
-import SetList, { SetListItem } from "./SetList";
+import SetList, { SetListItem, SetListMode } from "./SetList";
 import { Trash2 } from "lucide-react";
 
 type Props = {
   name: string;
   initials: string;
   items: SetListItem[];
 
   onChange?: (key: string | number, field: "reps" | "weight", value: string) => void;
   onRemove?: (key: string | number) => void;
   onAdd?: () => void;
+  onToggleDone?: (key: string | number, done: boolean) => void;
 
   // Behavior / UI
   disabled?: boolean;
   onFocusScroll?: React.FocusEventHandler<HTMLInputElement>;
   className?: string;
 
+  mode?: SetListMode;
+
   // Optional helper note under header
   note?: string;
 
   // NEW: delete exercise from routine
   onDeleteExercise?: () => void;
   deleteDisabled?: boolean;
 
   // Optional cancel and primary actions
   onCancel?: () => void;
   onPrimary?: () => void;
   primaryLabel?: string;
   primaryDisabled?: boolean;
 };
 
 const ExerciseSetEditorCard: React.FC<Props> = ({
   items,
   onChange,
   onRemove,
   onAdd,
+  onToggleDone,
   onDeleteExercise,
   deleteDisabled,
   disabled = false,
   onFocusScroll,
   className = "",
   note,
   onCancel,
   onPrimary,
   primaryLabel = "Save",
   primaryDisabled = false,
+  mode = "edit",
 }) => {
   return (
     <div className={["rounded-2xl bg-card/70 border border-border p-3 md:p-4", className].join(" ")}
     /* RAVI DBG: style={{ border: "2px solid red" }}*/>
       {note && (
         <p className="text-xs md:text-sm text-muted-foreground mb-3 italic bg-[var(--warm-cream)]/50 p-3 rounded-lg">
           {note}
         </p>
       )}
 
       {/* The unified set editor UI */}
       <SetList
-        mode="edit"
+        mode={mode}
         items={items}
-        onDeleteExercise={onDeleteExercise}
+        onDeleteExercise={mode === "workout" ? undefined : onDeleteExercise}
         deleteDisabled={deleteDisabled}
         onChange={onChange}
-        onRemove={onRemove}
+        onRemove={mode === "workout" ? undefined : onRemove}
         onAdd={onAdd}
+        onToggleDone={onToggleDone}
         onFocusScroll={onFocusScroll}
         disabled={disabled}
       />
 
       {/* Secondary row (trash/cancel) */}
-      {onCancel && (
+      {mode !== "workout" && onCancel && (
         <div className="mt-4 flex justify-end items-center gap-2">
           <TactileButton
             variant="secondary"
             size="sm"
             onClick={onCancel}
             disabled={disabled}
             className={`p-3 h-auto bg-card/70 border-destructive-light text-destructive hover:bg-destructive-light btn-tactile ${
               disabled ? "opacity-50 cursor-not-allowed" : ""
             }`}
             title="Cancel"
           >
             <Trash2 size={18} />
           </TactileButton>
         </div>
       )}
 
       {/* Primary CTA (optional) */}
-      {onPrimary && (
+      {mode !== "workout" && onPrimary && (
         <div className="mt-6">
           <TactileButton
             onClick={onPrimary}
             disabled={primaryDisabled || disabled}
             className={`w-full h-12 md:h-14 bg-primary text-primary-foreground font-medium rounded-full hover:bg-primary-hover btn-tactile ${
               primaryDisabled || disabled ? "opacity-50 cursor-not-allowed" : ""
             }`}
           >
             {primaryLabel}
           </TactileButton>
         </div>
       )}
     </div>
   );
 };
 
 export default ExerciseSetEditorCard;
\ No newline at end of file
diff --git a/components/sets/SetList.tsx b/components/sets/SetList.tsx
index 9e40558aa59638181757c3d971a3a4880a6616fa..45330d614f0c5bfc66daadc627a7730a1583cca2 100644
--- a/components/sets/SetList.tsx
+++ b/components/sets/SetList.tsx
@@ -1,179 +1,192 @@
 // components/sets/SetList.tsx
 import * as React from "react";
 import { Input } from "../ui/input";
 import { TactileButton } from "../TactileButton";
 import { X, Plus, Trash2 } from "lucide-react";
 
-export type SetListMode = "view" | "edit";
+export type SetListMode = "view" | "edit" | "workout";
 
 export interface SetListItem {
   key: string | number;
   order: number;
   reps?: string;
   weight?: string;
   removable?: boolean;
+  done?: boolean;
 }
 
 export interface SetListProps {
   /** Back-compat: if mode !== "edit" we render read-only (but same layout) */
   mode?: SetListMode;
   items: SetListItem[];
 
   /** Used when interactive */
   onChange?: (key: string | number, field: "reps" | "weight", value: string) => void;
   onRemove?: (key: string | number) => void;
   onAdd?: () => void;
+  onToggleDone?: (key: string | number, done: boolean) => void;
 
   /** Optional: delete the entire exercise (parent handles actual removal from routine) */
   onDeleteExercise?: () => void;
   deleteTitle?: string;
   deleteDisabled?: boolean;
 
   /** Optional focus helper for keyboard scroll-into-view */
   onFocusScroll?: React.FocusEventHandler<HTMLInputElement>;
 
   /** Force read-only/disabled */
   disabled?: boolean;
 
   className?: string;
 }
 
 const SetList: React.FC<SetListProps> = ({
   mode = "edit",
   items,
   onChange,
   onRemove,
   onAdd,
   onDeleteExercise,
   deleteTitle = "Remove this exercise from the routine",
   deleteDisabled = false,
   onFocusScroll,
   disabled = false,
   className = "",
 }) => {
   // Single unified layout. Read-only when disabled OR not in explicit edit mode.
-  const readOnly = disabled || mode !== "edit";
+  const readOnly = disabled || mode === "view";
   const isDisabled = readOnly || deleteDisabled;
 
   // DEBUG: Log the overall component state
   React.useEffect(() => {
     /*logger.debug("üîç SetsList DEBUG: Component state:", {
       mode,
       disabled,
       readOnly,
       itemsCount: items.length,
       hasOnRemove: !!onRemove,
       hasOnChange: !!onChange,
       hasOnAdd: !!onAdd,
       hasOnDeleteExercise: !!onDeleteExercise,
       hasOnFocusScroll: !!onFocusScroll,
       className
     }) */
   }, [
     mode,
     disabled,
     readOnly,
     items.length,
     onRemove,
     onChange,
     onAdd,
     onDeleteExercise,
     onFocusScroll,
     className
   ]);
 
   return (
     <div className={className}>
       {/* Header row ‚Äî identical to configure card */}
       <div className="grid grid-cols-4 gap-3 md:gap-4 text-[10px] md:text-xs text-warm-brown/60 uppercase tracking-wider mb-2"
       /* RAVI DBG: style={{ border: "2px solid green" }}*/>
         <span>Set</span>
         <span className="text-center">Reps</span>
         <span className="text-center">Weight (kg)</span>
         <span />
       </div>
 
       <div className="space-y-3"
       /*RAVI DBG:  style={{ border: "2px solid blue" }}*/>
         {items.map((it) => {
           const canRemove =
-            !readOnly && !!onRemove && (it.removable ?? true) && items.length > 1;
+            mode === "edit" && !readOnly && !!onRemove && (it.removable ?? true) && items.length > 1;
 
           // DEBUG: Log detailed canRemove calculation for each item
           /*logger.debug(`üîç SetsList DEBUG: Set ${it.order} (key: ${it.key}) canRemove calculation:`, {
             setOrder: it.order,
             setKey: it.key,
             readOnly,
             hasOnRemove: !!onRemove,
             itemRemovable: it.removable,
             itemRemovableDefault: it.removable ?? true,
             itemsLength: items.length,
             itemsLengthCheck: items.length > 1,
             canRemove,
             condition1_notReadOnly: !readOnly,
             condition2_hasOnRemove: !!onRemove,
             condition3_itemRemovable: it.removable ?? true,
             condition4_itemsLengthGreaterThan1: items.length > 1,
             finalResult: canRemove
           });*/
 
           return (
             <div
               key={it.key}
-              className="grid grid-cols-4 gap-3 md:gap-4 items-center py-2 px-3 bg-soft-gray/30 rounded-lg border border-border/20"
+              className={`grid grid-cols-4 gap-3 md:gap-4 items-center py-2 px-3 bg-soft-gray/30 rounded-lg border border-border/20 ${
+                mode === "workout" && it.done ? "opacity-60" : ""
+              }`}
               /*RAVI DBG: style={{ border: "2px solid yellow" }}*/>
               <span className="text-sm font-medium text-warm-brown/80">
                 {it.order}
               </span>
 
               <Input
                 type="tel"
                 inputMode="numeric"
                 pattern="[0-9]*"
                 value={it.reps ?? "0"}
                 onFocus={onFocusScroll}
                 onChange={(e) => onChange?.(it.key, "reps", e.target.value)}
                 disabled={readOnly}
                 className={`bg-input-background border-border text-foreground text-center h-10 md:h-8 rounded-md focus:border-warm-sage focus:ring-warm-sage/20 text-sm ${readOnly ? "opacity-50 cursor-not-allowed" : ""}`}
                 min="0"
               />
 
               <Input
                 type="number"
                 inputMode="decimal"
                 pattern="[0-9]*[.,]?[0-9]*"
                 step="0.5"
                 value={it.weight ?? "0"}
                 onFocus={onFocusScroll}
                 onChange={(e) => onChange?.(it.key, "weight", e.target.value)}
                 disabled={readOnly}
                 className={`bg-input-background border-border text-foreground text-center h-10 md:h-8 rounded-md focus:border-warm-sage/20 text-sm ${readOnly ? "opacity-50 cursor-not-allowed" : ""}`}
                 min="0"
               />
 
-              {canRemove ? (
+              {mode === "workout" ? (
+                <div className="flex justify-end">
+                  <input
+                    type="checkbox"
+                    checked={!!it.done}
+                    onChange={(e) => onToggleDone?.(it.key, e.target.checked)}
+                    className="w-5 h-5 ml-auto"
+                  />
+                </div>
+              ) : canRemove ? (
                 <TactileButton
                   variant="secondary"
                   size="sm"
                   onClick={() => onRemove?.(it.key)}
                   className="p-1 h-auto bg-destructive-light text-destructive hover:bg-destructive ml-auto"
                   title="Remove this set"
                 >
                   <X size={14} />
                 </TactileButton>
               ) : (
                 // Spacer keeps grid width identical when read-only / not removable
                 <div className="w-6 h-6 ml-auto" />
               )}
             </div>
           );
         })}
       </div>
 
       {/* Bottom action row: Add on the left, Delete Exercise on the right */}
       {(onAdd || onDeleteExercise) && (
         <div className="mt-3 flex items-center justify-between">
           {/* Left: Add Set (only when interactive) */}
           {onAdd ? (
             <TactileButton
               onClick={onAdd}
diff --git a/test/utils/test-user.ts b/test/utils/test-user.ts
index 26fa959d4036ee2a60048c94ddaae346665079b0..623cb4c8cd1f81baef9729432e75e2f3c8ba39ee 100644
--- a/test/utils/test-user.ts
+++ b/test/utils/test-user.ts
@@ -1,30 +1,31 @@
 /**
  * Test User Management Utilities
- * 
+ *
  * Handles creation, management, and cleanup of test users
  */
+import { logger } from "../../utils/logging";
 
 export interface TestUser {
   email: string;
   password: string;
   id?: string;
   createdAt?: string;
 }
 
 /**
  * Creates a unique test user with timestamp-based email
  */
 export function createTestUser(): TestUser {
   const timestamp = Date.now();
   const randomSuffix = Math.random().toString(36).substring(2, 8);
   
   return {
     email: `test-user-${timestamp}-${randomSuffix}@workout-test.com`,
     password: 'TestPassword123!',
     createdAt: new Date().toISOString()
   };
 }
 
 /**
  * Creates multiple test users for batch testing
  */
diff --git a/utils/supabase/supabase-db-write.ts b/utils/supabase/supabase-db-write.ts
index d929ce72adcb1623565a7e0807818e265efe6e46..65c1268e81ccaf77bafa08e681dfccd485b423e6 100644
--- a/utils/supabase/supabase-db-write.ts
+++ b/utils/supabase/supabase-db-write.ts
@@ -1,27 +1,27 @@
 import { SupabaseBase, SUPABASE_URL } from "./supabase-base";
-import type { UserRoutine, UserRoutineExercise, UserRoutineExerciseSet, Profile } from "./supabase-types";
+import type { UserRoutine, UserRoutineExercise, UserRoutineExerciseSet, Profile, Workout, WorkoutExercise, Set } from "./supabase-types";
 import { logger } from "../logging";
 
 export class SupabaseDBWrite extends SupabaseBase {
     // Auth
     async signUp(email: string, password: string): Promise<{ token?: string; refresh_token?: string; needsSignIn?: boolean }> {
         const data = await this.fetchJson<any>(
             `${SUPABASE_URL}/auth/v1/signup`,
             false,
             "POST",
             { email, password }
         );
         if (data.error) throw new Error(data.error.message);
         if (data.access_token || data.session?.access_token) {
             return { 
                 token: data.access_token || data.session!.access_token,
                 refresh_token: data.refresh_token || data.session?.refresh_token
             };
         }
         return { needsSignIn: true };
     }
 
     async signIn(email: string, password: string): Promise<{ access_token: string; refresh_token: string }> {
         const data = await this.fetchJson<any>(
             `${SUPABASE_URL}/auth/v1/token?grant_type=password`,
             false,
@@ -162,50 +162,115 @@ export class SupabaseDBWrite extends SupabaseBase {
             `${SUPABASE_URL}/rest/v1/user_routine_exercises_data?routine_template_exercise_id=eq.${routineTemplateExerciseId}`,
             true,
             "PATCH",
             { is_active: false },
             "return=minimal"
         );
 
         // Also soft delete all associated sets
         await this.fetchJson(
             `${SUPABASE_URL}/rest/v1/user_routine_exercises_set_data?routine_template_exercise_id=eq.${routineTemplateExerciseId}`,
             true,
             "PATCH",
             { is_active: false },
             "return=minimal"
         );
 
         const routineId = await this.findRoutineIdForExercise(routineTemplateExerciseId);
 
         // Refresh the data
         await Promise.all([
             this.refreshRoutineExercises(userId, routineId),        // Routine ID
             this.refreshRoutineExercisesWithDetails(userId, routineId), // Routine ID
         ]);
     }
 
+    // ----- Workout flows -----
+    async startWorkout(routineTemplateId: number): Promise<Workout> {
+        const userId = await this.getUserId();
+        const rows = await this.fetchJson<Workout[]>(
+            `${SUPABASE_URL}/rest/v1/workouts`,
+            true,
+            "POST",
+            { template_id: routineTemplateId, started_at: new Date().toISOString(), user_id: userId },
+            "return=representation"
+        );
+        return rows[0];
+    }
+
+    async endWorkout(workoutId: string): Promise<void> {
+        await this.fetchJson(
+            `${SUPABASE_URL}/rest/v1/workouts?id=eq.${workoutId}`,
+            true,
+            "PATCH",
+            { ended_at: new Date().toISOString() },
+            "return=minimal"
+        );
+    }
+
+    async addWorkoutExercise(workoutId: string, exerciseId: number, order_index: number): Promise<WorkoutExercise> {
+        const rows = await this.fetchJson<WorkoutExercise[]>(
+            `${SUPABASE_URL}/rest/v1/workout_exercises`,
+            true,
+            "POST",
+            { workout_id: workoutId, exercise_id: exerciseId, order_index },
+            "return=representation"
+        );
+        return rows[0];
+    }
+
+    async addWorkoutSet(
+        workoutExerciseId: string,
+        set_index: number,
+        reps: number,
+        weight: number,
+        completed_at?: string
+    ): Promise<Set> {
+        const rows = await this.fetchJson<Set[]>(
+            `${SUPABASE_URL}/rest/v1/sets`,
+            true,
+            "POST",
+            { workout_exercise_id: workoutExerciseId, set_index, reps, weight, completed_at },
+            "return=representation"
+        );
+        return rows[0];
+    }
+
+    async updateWorkoutSet(
+        setId: string,
+        patch: Partial<Pick<Set, "reps" | "weight" | "completed_at">>
+    ): Promise<Set> {
+        const rows = await this.fetchJson<Set[]>(
+            `${SUPABASE_URL}/rest/v1/sets?id=eq.${setId}`,
+            true,
+            "PATCH",
+            patch,
+            "return=representation"
+        );
+        return rows[0];
+    }
+
     async updateExerciseSet(
         routineTemplateExerciseSetId: number,
         plannedReps?: number,
         plannedWeightKg?: number
     ): Promise<UserRoutineExerciseSet | null> {
         const userId = await this.getUserId();
 
         // find parent rtex id to know which cache to refresh
         const lookup = await this.fetchJson<Array<{ routine_template_exercise_id: number }>>(
             `${SUPABASE_URL}/rest/v1/user_routine_exercises_set_data?routine_template_exercise_set_id=eq.${routineTemplateExerciseSetId}&select=routine_template_exercise_id`,
             true
         );
         const parentId = lookup[0]?.routine_template_exercise_id;
 
         const rows = await this.fetchJson<UserRoutineExerciseSet[]>(
             `${SUPABASE_URL}/rest/v1/user_routine_exercises_set_data?routine_template_exercise_set_id=eq.${routineTemplateExerciseSetId}`,
             true,
             "PATCH",
             {
                 planned_reps: plannedReps && plannedReps > 0 ? plannedReps : null,
                 planned_weight_kg: plannedWeightKg && plannedWeightKg > 0 ? plannedWeightKg : null,
             },
             "return=representation"
         );
         if (parentId) await this.refreshRoutineSets(userId, parentId);
 
EOF
)
